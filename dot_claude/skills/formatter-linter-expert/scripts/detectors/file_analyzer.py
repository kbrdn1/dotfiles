"""
File Analyzer - Analyzes file types and patterns
"""

from pathlib import Path
from typing import List, Set, Dict


class FileAnalyzer:
    """Analyzes files to determine their ecosystem"""

    # Extension to ecosystem mapping
    EXTENSION_MAP = {
        ".php": ["php", "laravel"],
        ".js": ["javascript", "node", "bun"],
        ".jsx": ["javascript", "react", "node", "bun"],
        ".ts": ["typescript", "node", "bun"],
        ".tsx": ["typescript", "react", "node", "bun"],
        ".vue": ["vue", "javascript", "typescript"],
        ".astro": ["astro"],
        ".go": ["go"],
        ".rs": ["rust"],
        ".py": ["python"],
        ".rb": ["ruby"]
    }

    def __init__(self, project_root: Path):
        self.project_root = project_root

    def analyze_file(self, file_path: Path) -> List[str]:
        """
        Analyze a single file to determine possible ecosystems

        Args:
            file_path: Path to file

        Returns:
            List of possible ecosystem names
        """
        extension = file_path.suffix.lower()
        return self.EXTENSION_MAP.get(extension, ["unknown"])

    def analyze_directory(self, directory: Path) -> Dict[str, int]:
        """
        Analyze a directory to determine ecosystem distribution

        Args:
            directory: Directory to analyze

        Returns:
            Dict mapping ecosystem to file count
        """
        ecosystem_counts = {}

        for file_path in directory.rglob("*"):
            if file_path.is_file():
                ecosystems = self.analyze_file(file_path)

                for ecosystem in ecosystems:
                    ecosystem_counts[ecosystem] = ecosystem_counts.get(ecosystem, 0) + 1

        return ecosystem_counts

    def get_dominant_ecosystem(self, file_paths: List[Path]) -> str:
        """
        Determine the dominant ecosystem from a list of files

        Args:
            file_paths: List of file paths

        Returns:
            Dominant ecosystem name
        """
        ecosystem_counts = {}

        for file_path in file_paths:
            ecosystems = self.analyze_file(file_path)

            for ecosystem in ecosystems:
                ecosystem_counts[ecosystem] = ecosystem_counts.get(ecosystem, 0) + 1

        if not ecosystem_counts:
            return "unknown"

        # Return ecosystem with highest count
        return max(ecosystem_counts, key=ecosystem_counts.get)

    def filter_files_by_ecosystem(
        self,
        file_paths: List[Path],
        ecosystem: str
    ) -> List[Path]:
        """
        Filter files that belong to a specific ecosystem

        Args:
            file_paths: List of file paths
            ecosystem: Ecosystem name to filter by

        Returns:
            Filtered list of file paths
        """
        filtered = []

        for file_path in file_paths:
            ecosystems = self.analyze_file(file_path)

            if ecosystem in ecosystems:
                filtered.append(file_path)

        return filtered

    def get_file_extensions_for_ecosystem(self, ecosystem: str) -> Set[str]:
        """
        Get all file extensions associated with an ecosystem

        Args:
            ecosystem: Ecosystem name

        Returns:
            Set of file extensions (including dot)
        """
        extensions = set()

        for ext, ecosystems in self.EXTENSION_MAP.items():
            if ecosystem in ecosystems:
                extensions.add(ext)

        return extensions

    def is_generated_file(self, file_path: Path) -> bool:
        """
        Check if file is likely auto-generated

        Args:
            file_path: Path to file

        Returns:
            True if likely generated
        """
        # Common patterns for generated files
        generated_patterns = [
            "generated",
            ".gen.",
            "_gen.",
            ".generated.",
            "auto-generated",
            "DO NOT EDIT",
            "autogenerated"
        ]

        # Check filename
        filename = file_path.name.lower()
        for pattern in generated_patterns:
            if pattern in filename:
                return True

        # Check directory path
        path_str = str(file_path).lower()
        if any(x in path_str for x in ["generated", "build", "dist", ".next", ".nuxt"]):
            return True

        # Try to read first few lines for generation markers
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                first_lines = "".join(f.readline() for _ in range(10)).lower()

                for pattern in generated_patterns:
                    if pattern in first_lines:
                        return True

        except (IOError, UnicodeDecodeError):
            pass

        return False

    def should_exclude_file(self, file_path: Path, exclude_patterns: List[str]) -> bool:
        """
        Check if file should be excluded based on patterns

        Args:
            file_path: Path to file
            exclude_patterns: List of exclusion patterns

        Returns:
            True if file should be excluded
        """
        path_str = str(file_path)

        for pattern in exclude_patterns:
            if pattern in path_str:
                return True

        # Check if generated
        if self.is_generated_file(file_path):
            return True

        return False
